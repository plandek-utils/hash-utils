{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { createHash } from \"node:crypto\";\nimport sortKeys from \"sort-keys\";\n\n/**\n * JSON.stringify with the object keys deeply sorted\n *\n * @param input Object to stringify\n * @returns JSON String\n */\nexport function sortedJSONFor(input: Record<string, unknown>): string {\n  return JSON.stringify(sortKeys(input, { deep: true }));\n}\n\n/**\n * Creates an id with the hash from a JSON object, with an optional prefix. The hash is based on the sorted JSON string.\n *\n * @param prefix Optional prefix for the id (e.g. \"my-prefix--HASH\"). If blank, then the id returned will be just the hash.\n * @param input Object to serialize and hash\n * @returns\n */\nexport function idFromComplex(prefix: string | null, input: Record<string, unknown>): string {\n  const hash = hashFromString(sortedJSONFor(input));\n  const pre = prefix ? `${prefix}--` : \"\";\n  return `${pre}${hash}`;\n}\n\n/**\n * Makes a hash from a string, using SHA-512 in URL-safe base64 encoding.\n *\n * @param str\n * @returns\n */\nexport function hashFromString(str: string): string {\n  const b64 = createHash(\"sha512\").update(str).digest(\"base64\");\n  return b64.replace(REGEX_BASE64_URL, (x) => BASE64_URL_REPLACEMENT_MAP[x]);\n}\n\nconst REGEX_BASE64_URL = /[=+\\/]/g;\nconst BASE64_URL_REPLACEMENT_MAP: Record<string, string> = {\n  \"/\": \"_\",\n  \"+\": \"-\",\n  \"=\": \"\",\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,yBAA2B;AAC3B,uBAAqB;AAQd,SAAS,cAAc,OAAwC;AACpE,SAAO,KAAK,cAAU,iBAAAA,SAAS,OAAO,EAAE,MAAM,KAAK,CAAC,CAAC;AACvD;AASO,SAAS,cAAc,QAAuB,OAAwC;AAC3F,QAAM,OAAO,eAAe,cAAc,KAAK,CAAC;AAChD,QAAM,MAAM,SAAS,GAAG,MAAM,OAAO;AACrC,SAAO,GAAG,GAAG,GAAG,IAAI;AACtB;AAQO,SAAS,eAAe,KAAqB;AAClD,QAAM,UAAM,+BAAW,QAAQ,EAAE,OAAO,GAAG,EAAE,OAAO,QAAQ;AAC5D,SAAO,IAAI,QAAQ,kBAAkB,CAAC,MAAM,2BAA2B,CAAC,CAAC;AAC3E;AAEA,IAAM,mBAAmB;AACzB,IAAM,6BAAqD;AAAA,EACzD,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACP;","names":["sortKeys"]}